Java虚拟机加载类，从class文件到内存中的类，按照先后顺序需要经过**加载**、**链接**、**初始化**三大步骤。

- 链接过程需要进行验证
- 内存中的类没有经过初始化不能使用

# Java语言的类型
## 1. 基本类型（primitive types）
由Java虚拟机预先定义好。
## 2. 引用类型（reference types）
分为四大类。
1. 类（有对应的字节流）
2. 接口（有对应的字节流）
3. 数组类（由Java虚拟机直接生成）
4. 泛型参数（编译过程中会被擦除）

Java虚拟机实际上只有前三种引用类型。

### 字节流：
1. 最常见的形式是由Java编译器生成的**class文件**。
2. 在程序内直接生成
3. 从网络中获取字节流（如网页中内嵌的小程序Java applet）

不同形式的字节流都会被加载到Java虚拟机中，成为类或者接口。

**不论是直接生成的数组类，还是加载的类，Java虚拟机都需要对它们进行链接和初始化。**

# 加载
加载是指查找字节流，并且据此创建类的过程。
- 对于数组类来说，它并没有对应的字节流，而是由Java虚拟机**直接生成**
- 对于其他的类来说，Java虚拟机需要借助**类加载器**来完成查找字节流的过程


> **启动类加载器**（boot class loader）：**由C++实现**，++没有对应的Java对象++，因此在Java中只能用null来指代。

> 在Java 9 之前，启动类加载器负责加载最基础、最重要的类（比如存放在JRE的lib目录下的jar包中的类，以及有虚拟机参数-Xbootclasspath指定的类）。

除了启动类加载器之外，其他的类加载器都是**java.lang.ClassLoader**的子类，因此有对应的Java对象。++这些类加载器需要先由另一个类加载器（比如**启动类加载器**）加载至Java虚拟机中，方能执行类加载++。

>  **双亲委派模型**：在Java虚拟机中，每当一个类加载器接收到加载请求，它会++先将请求转发给父类加载器++，在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

除了启动类加载器之外，另外两个重要的类加载器是：
- 扩展类加载器（extension class  loader）：**父类加载器是启动类加载器**，它负责加载++相对次要、但又通用的类++（比如存放在JRE的lib/ext目录下的jar包中的类，以及由系统变量java.ext.dirs指定的类）。
- 应用类加载器（application class loader）：**父类加载器是扩展类加载器**，它负责加载应用程序路径下的类（如虚拟机参数-cp/-classpath、系统变量java.class.path或者环境变量CLASSPATH所指定的路径）。默认情况下，应用程序中包含的类便是由应用类加载器加载的。

**它们均由Java核心类库提供。**

> Java 9 引入了模块系统，并且略微更改了上述的类加载器，扩展类加载器更名为平台类加载器（platform class loader）。Java SE中除了少数几个关键模块（java.base）是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

### 自定义类加载器
除了由Java核心类库提供的类加载器之外，还可以自定义类加载器，来实现特殊的加载方式。

> 例如，可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。

除了加载功能之外，类加载器还提供了**命名空间**的作用，打个比方，咱们这个村不讲究版权，如果你剽窃了另一个建筑师的设计作品，那么只要你标上自己的名字，这两个房型就是不同的。

Java虚拟机中，++类的唯一性是由**类加载器实例**以及**类的全名**一同确定的++。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，可以借助这个特性，来运行同一个类的不同版本。

# 链接
将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可分为**验证**、**准备**以及**解析**三个阶段。

### 验证阶段
目的在于确保被加载的类能够满足Java虚拟机的约束条件。

> 通常而言，Java编译器生成的类文件必须满足Java虚拟机的约束条件，详细见 字节码注入章节。

### 准备阶段
目的是为被加载类的静态字段分配内存。

Java代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。（++过了这个阶段，算是盖好了毛坯房，虽然结构已经完整了，但是在没有装修之前是不能住人的++）。

> 除了分配内存外，部分Java虚拟机还会在此阶段++构造其他跟类层次相关的数据结构++，比如用来实现虚方法的动态绑定的方法表。

++在class文件被加载至Java虚拟机之前，这个类无法知道其他类及方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址++。因此，每当需要引用这些成员时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

> 举个例子，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

### 解析阶段
目的正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）。

Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。


# 初始化
在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

- 如果直接赋值的静态字段被final所修饰，并且它的类型是**基本类型**或**字符串**时，那么该字段便会被Java编译器标记为**常量值**（ConstantValue），其初始化直接由++Java虚拟机完成++。
- 除此之外的**直接赋值操作**，以及**所有静态代码块中的代码**，则会被Java编译器置于同一方法中，并把它命名为<clinit>。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行<clinit>方法的过程。Java虚拟机会通过**加锁**来确保类的<clinit>方法仅被执行一次。

**只有当初始化完成后，类才正式成为可执行的状态。**

JVM规范枚举的触发初始化的情况：
1. 当虚拟机启动时，初始化用户指定的主类
2. 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类
5. 子类的初始化会触发父类的初始化
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化
7. 使用反射API对某个类进行反射调用时，初始化这个类
8. 当初次调用MethodHandler实例时，初始化该MethodHandler指向的方法所在的类


```
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
```
以上代码，著名的单利延迟初始化例子，只有当调用Singleton.getInstance时，程序才会访问LazyHandler.INSTANCE，才会触发对LazyHolder的初始化（对应第四种情况），继而创建一个Singleton的实例。

**类初始化是线程安全的，并且只会被初始化一次，因此程序可以确保多线程环境下有且仅有一个Singleton实例。**

# 总结
Java虚拟机将字节流转换为Java类的过程：
1. 加载
2. 链接
3. 初始化

- 加载：是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在Java虚拟机中，类加载器使用双亲委派模型，即接收到加载请求时，会先转发给父类加载器。
- 链接：是指将创建的类合并至Java虚拟机中，使之能够执行的过程。链接还分为验证、准备和解析三个阶段，其中解析阶段是非必须的。
- 初始化：是指为标记为常量值的字段赋值，以及执行<clinit>方法的过程。类的初始化被执行一次，这个特性被用来实现单例模式的延迟初始化。

