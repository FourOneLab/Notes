可变长参数方法的重载：

```
void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

invoke(null, 1);    // 调用第二个 invoke 方法
invoke(null, 1, 2); // 调用第二个 invoke 方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，才能调用第一个 invoke 方法
```

**官方建议避免重载可变长参数方法。**因为Java编译器可能无法决定应该调用哪个目标方法。

> 这种情况下，编译器会报错，并且提示这个方法存在二义性。但是Java编译器直接将上述代码的方法调用识别为第二个方法，这是何为？

# Java编译器是怎么识别目标方法的
## 重载与重写
在Java程序里，如果同一个类出现多个名字相同，并且参数类型相同的方法，那么它无法它能够个编译。正常情况下，如果想要在同一个类中定义**名字相同的方法**，那么它们的**参数类型必须不同**。这些方法之间的关系，称为重载。

>  小知识：这个限制可以通过字节码工具绕开。也就是说，在编译完成之后，我们可以再向 class 文件中添加方法名和参数类型相同，而返回类型不同的方法。当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在 Java 编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？++当前版本的 Java 编译器会直接选取第一个方法名以及参数类型匹配的方法++。并且，它会**根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等**。

重载的方法在**编译过程**中即可完成识别。具体到每一个方法调用，Java编译器会根据所传入参数的**声明类型**（注意与实际类型区分）来选取重载方法。

选取过程共分为三个阶段：
1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法。
2. 如果在第1个阶段中没有找到适配的方法，那么在运行自动装拆箱，但不允许可变长参数的情况下选取重载方法。
3. 如果在第2个阶段中没有找到适配的方法，那么在运行自动装拆箱以及可变长参数的情况下选取重载方法。


阶段| 自动装拆箱 | 可变长参数
---|---|---
1 | N | N
2 | Y | N
3 | Y | Y

如果Java编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而**决定贴切程度的一个关键就是形式参数类型的继承关系**。

> 在上面的一段代码中，当传入null时，它既可以匹配第一个方法中声明的Object的形式参数，也可以匹配第二个方法中声明为String的形式参数。**由于String是Object的子类，因此，Java编译器会认为第二个方法更为贴切。**

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中这两个方法同样构成重载。

**如果子类定义了与父类中非私有方法同名的方法，而且这两个方法参数类型相同，那么这两个方法之间是什么关系？**

1. 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。
2. 如果这两个方法都不是静态的，且都不是私有的，那么子类中的方法重写了父类中的方法。

> 方法重写，正是**多态**的一种体现形式：它运行子类在继承父类部分功能的同时，拥有自己独特的行为。重写方法调用，它会根据调用者的动态类型，来选取实际的目标方法。

## JVM静态绑定和动态绑定
Java虚拟机如何识别方法？

Java虚拟机识别方法的关键在于**类名**、**方法名**以及**方法描述符**。

> 方法描述符：它是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么Java虚拟机会在类验证阶段报错。

Java虚拟机与Java语言不通，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型， 因此Java虚拟机能够准确地识别目标方法。

Java虚拟机中关于**方法重写**的判定同样++基于方法描述符++。如果子类定义了与父类中**非私有**、**非静态方法**同名的方法，那么只有当这两个方法的**参数类型**以及**返回类型**一致，Java虚拟机才会判定为重写。

> 对于Java语言中重写而Java虚拟机中非重写的情况，编译器会通过生成**桥接方法**来实现Java中的重写语义。

---
由于重载方法的区分在编译阶段已经完成，可以认为Java虚拟机不存在重载的概念。一般认为：
- 重载：静态绑定或编译时多态
- 重写：动态绑定

> 这个说法在Java虚拟机语境下并非完全正确。因为某个类中的重载方法可能被它的子类所重写，因++此Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型++。

确切的说，Java虚拟机中：
- 静态绑定:指的是在解析时便能够直接识别目标方法的情况。
- 动态绑定：是指需要在运行中根据调用者的动态类型来识别目标方法的情况。


Java字节码中与调用相关的指令共有5种：
1. invokeststic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器、以及使用super关键字调用父类的实例方法和构造器，和所有实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。（复杂）

以下代码展示编译生成前四种调用指令的情况：

```
interface 客户 {
  boolean isVIP();
}

class 商户 {
  public double 折后价格 (double 原价, 客户 某客户) {
    return 原价 * 0.8d;
  }
}

class 奸商 extends 商户 {
  @Override
  public double 折后价格 (double 原价, 客户 某客户) {
    if (某客户.isVIP()) {                         // invokeinterface      
      return 原价 * 价格歧视 ();                    // invokestatic
    } else {
      return super. 折后价格 (原价, 某客户);          // invokespecial
    }
  }
  public static double 价格歧视 () {
    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。
    return new Random()                          // invokespecial
           .nextDouble()                         // invokevirtual
           + 0.8d;
  }
}
```

在代码中，“商户”类定义了一个成员方法，叫做“折后价格”，它将接收一个 double 类型的参数，以及一个“客户”类型的参数。这里“客户”是一个接口，它定义了一个接口方法，叫“isVIP”。

我们还定义了另一个叫做“奸商”的类，它继承了“商户”类，并且重写了“折后价格”这个方法。如果客户是 VIP，那么它会被给到一个更低的折扣。

在这个方法中，我们首先会调用“客户”接口的”isVIP“方法。该调用会被编译invokeinterface 指令。
如果客户是 VIP，那么我们会调用奸商类的一个名叫“价格歧视”的静态方法。该调用会被编译为
invokestatic 指令。如果客户不是 VIP，那么我们会通过 super 关键字调用父类的“折后价格”方
法。该调用会被编译为 invokespecial 指令。
在静态方法“价格歧视”中，我们会调用 Random 类的构造器。该调用会被编译为 invokespecial
指令。然后我们会以这个新建的 Random 对象为调用者，调用 Random 类中的 nextDouble 方
法。该调用会被编译为 invokevirutal 指令。
对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。
而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，
根据调用者的动态类型，来确定具体的目标方法。
唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final[3]
[4]，那么它可以不通过动态类型，直接确定目标方法。

## 调用指令的符号引用
在编译过程中，并不知道目标方法的具体内存地址。因此，Java编译器会暂时用符号引用来表示该目标方法。

> 符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。

符号引用存储在class文件的**常量池**中，根据目标方法是否为接口方法，符号引用分为：
1. 接口符号引用
2. 非接口符号引用


使用 javap -v 打印某个类的常量池。