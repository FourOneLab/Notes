>HotSpot虚拟机的Java堆中对象的分配、布局和访问过程。

# 对象的创建
Java是面向对象的语言，Java程序运行的过程中每时每刻都有对象被创建出来。在语言层面创建对象通常仅仅是一个**new关键字**。

虚拟机遇到一条new语句：
1. 首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用（==参数-->类符号引用==）
2. 检查这个符号引用代表的类是否已经被加载、解析和初始化（==类符号引用-->类加载、解析、初始化==）
3. 如果没有，必须先执行相应的类加载过程（==否--> 类加载==）
4. 类加载检查通过后，虚拟机降为新生对象分配内存（==是-->新对象分配内存==）【对象所需的内存在类加载完后就完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来】


### 内存的分配方式
- **指针碰撞**：用过的内存在一边，空闲的内存在另一边；分配内存仅仅是把指针向空闲空间那边挪动一段和对象大小相等的距离
- **空闲列表**：用过的内存和空闲的内存交错存在，虚拟机就必须维护一个列表（记录哪些内存块可用），在分配时从列表中找出足够大的空间划分给对象实例并更新列表上的记录

```
graph LR
垃圾收集器是否带有压缩整理功能决定-->Java堆是否规整决定
Java堆是否规整决定-->内存的分配方式
```

内存分配方式 | 典型的垃圾收集器 | 是否带有压缩功能
---|---| ---
指针碰撞 | Serial、ParNew | 是
空闲列表 | Mark-Sweep | 否


##### 对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。

解决这个问题的两种方案：
1. 对分配内存空间的动作进行同步处理---采用CAS配上失败重试的方式保证更新操作的原子性
2. 把内存分配的动作按照线程划分在不同的空间中进行---即每个线程在Java堆上预先分配一小块内存区域，本地线程分配缓冲（TLAB），只有在TLAB用完并且需要分配新的TLAB时需要同步锁【-XX:+/ -UserTLAB参数来设定】

**++内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这样保证了对象的实例字段在Java代码中可以不初始化而直接使用++。**

- 对象头：保存了类的元数据信息、对象的哈希码、对象的GC分代年龄等信息 

空间初始化后，虚拟机根据对象头中的信息对对象进行必要的设置。

# 对象的内存布局
对象在内存中存储的布局分为3块区域：
1. **对象头**（Header）、【==与对象自身定义的数据无关的额外存储成本==，考虑到虚拟机的空间效率，根据对象状态复用自己的存储空间】
2. **实例数据**（Instance Data）、
3. **对齐填充**（Padding）

#### 对象头
1. 存储对象自身的**运行时数据**：（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）【32bit / 64bit】
2. 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
3. 记录数组长度的数据：【当对象是一个Java数组的时候需要这个】


#### 实例数据
记录对象真正存储的有效信息，即在程序代码中定义的各种类型的字段内容；无论是在父类继承（父类中定义的变量会出现在子类之前）还是子类定义，都要被记录。

++如果CompactFields参数值为true，那么子类中较窄的字段会插入到父类变量的间隙中++

>这部分的存储顺序受到虚拟机分配策略参数和字段在Java源码中的定于顺序的影响，HopSpot的分配策略，longs/doubles ints shorts/chats bytes/booleans oops(Ordinary Object Pointers)，从中可以看出，相同宽度的字段总是被分配到一起


#### 对齐填充
- 并不是必须存在的
- 仅仅起到占位符的作用

>HotSpot的内存管理系统要求对象起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍

对象头正好是8字节的倍数（1倍或2倍），因此，当对象实例数据没有对齐的时候，对齐填充来补充

# 对象的访问定位
建立对象是为了访问对象，Java程序通过栈上的reference数据（一个指向对象的引用，如何定位访问堆中对象的具体位置有虚拟机实现）来操作堆上的具体对象。

主流的对象访问方式：
- 句柄
- 直接指针

两种访问的优势：
- 通过句柄访问的最大好处，reference中存储的是稳定的句柄地址，在对象被移动时只要改变句柄中的实例数据指针，reference本身不需要修改
- 使用指针访问的最大好处,速度更快，节省了一次指针定位的时间开销

#### 句柄
Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象的实例数据和类型数据各自的具体地址信息
![image](https://note.youdao.com/yws/public/resource/2a9d776b887651686e00ee8b72f722ff/xmlnote/DA3E1338DBD14ECEBDF7D6DAD55DF51C/7268)

#### 直接指针
Java堆对象布局中必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址
![image](https://note.youdao.com/yws/public/resource/2a9d776b887651686e00ee8b72f722ff/xmlnote/EF3370FE25834F90B1638FA93CDBD0A3/7271)