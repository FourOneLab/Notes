# 程序空间与内核空间
在Linux中，对于一次读取IO的操作，数据并不会直接拷贝到程序的程序缓冲区。它首先会被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区。**ps: 最后一句话非常重要，重复一遍。**

# Block
考虑下面两种情况：

- 用系统调用read从socket里读取一段数据
- 用系统调用read从一个磁盘文件读取一段数据到内存

直觉认为这两种都算“Block”，但Linux不这么认为。

Linux认为：

- 对于第一种情况，算作block，因为Linux无法知道网络上对方是否会发数据。如果没数据发过来，对于调用read的程序来说，就只能“等”。
- 对于第二种情况，不算做block。

**对于磁盘文件IO，Linux总是不视作Block**。

> 所谓“Block”是指操作系统**可以预见**这个Block会发生才会主动Block。
> - 例如当读取TCP连接的数据时，如果发现Socket buffer里没有数据就可以确定定对方还没有发过来，于是Block；而对于普通磁盘文件的读写，也许磁盘运作期间会抖动，会短暂暂停，但是操作系统无法预见这种情况，只能视作不会Block，照样执行。


基于这个基本的设定，在讨论IO时，一定要严格区分++网络IO++和++磁盘文件IO++。NIO和后文讲到的IO多路复用只对网络IO有意义。

严格的说，O_NONBLOCK和IO多路复用，对标准输入输出描述符、管道和FIFO也都是有效的。
# IO
IO的方式通常分为几种：
1. 同步阻塞的BIO
2. 同步非阻塞的NIO
3. 异步非阻塞的AIO

## IO场景
### 同步阻塞IO（BIO）

![image](http://p1.pstatp.com/large/pgc-image/154088427500480e0ddb6cb)

用户进程在发起一个IO操作以后，**必须等待IO操作的完成**，只有当真正完成了IO操作以后，用户进程才能运行。++JAVA传统的IO模型属于此种方式！++

> Block是不会影响同时运行的其他程序（进程）的，因为现代操作系统都是多任务的，任务之间的切换是抢占式的。这里Block只是指Block当前的进程。


网络服务为了同时响应多个并发的网络请求，必须实现为多线程的。每个线程处理一个网络请求。线程数随着并发连接数线性增长。这的确能奏效。实际上2000年之前很多网络服务器就是这么实现的。但这带来两个问题：

1. 线程越多，Context Switch就越多，而Context Switch是一个比较重的操作，会无谓浪费大量的CPU。
2. 每个线程会占用一定的内存作为线程的栈。比如有1000个线程同时运行，每个占用1MB内存，就占用了1个G的内存。

问题的关键在于，当调用read接受网络请求时，有数据到了就用，没数据到时，实际上是可以干别的。使用大量线程，仅仅是因为Block发生，没有其他办法。

**要是操作IO接口时，操作系统能够总是直接告诉有没有数据，而不是Block去等就好了。于是，NIO登场。**
### 同步非阻塞IO（NIO）:

![image](http://p9.pstatp.com/large/pgc-image/1540884275026551e76d1ec)

用户进程发起一个IO操作以后便**可返回做其它事情**，++但是用户进程需要时不时的询问IO操作是否就绪++，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。++目前JAVA的NIO就属于同步非阻塞IO。++

**这时，BIO和NIO的区别是什么呢？**

- 在BIO模式下，调用read，如果发现没数据已经到达，就会Block住。
- 在NIO模式下，调用read，如果发现没数据已经到达，就会立刻返回-1, 并且errno被设为EAGAIN。

但这样会带来两个新问题：

1. 如果有大量文件描述符都要等，那么就得一个一个的read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）
2. 休息一会的时间不好把握。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。


在非阻塞状态下，我们的过程一(wait for data)并不是完全的阻塞的，但是过程二(copy data from kernel to user)依然处于一个阻塞状态。

**要是操作系统能一口气告诉程序，哪些数据到了就好了。**

于是IO多路复用被搞出来解决这个问题。

### 异步阻塞IO（NIO）：

![image](http://p99.pstatp.com/large/pgc-image/15408842744064880df38ee)

用户进程发起一个IO操作以后，**不等待内核IO操作的完成**，等内核完成IO操作以后会通知用户进程。

> 这就是同步和异步最关键的区别:
> - 同步**必须等待或者主动的去询问IO是否完成**

**那么为什么说是阻塞的呢？**

因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！

### 异步非阻塞IO（AIO）:

![image](http://p99.pstatp.com/large/pgc-image/1540884275061e9fcfb1dab)

用户进程只需要发起一个IO操作然后**立即返回**，等IO操作真正的完成以后，++用户进程会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了++，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。

## 小结
![image](http://p99.pstatp.com/large/pgc-image/15408842745638ad0732992)


- 阻塞式IO(默认)，非阻塞式IO(nonblock)，IO复用(select/poll/epoll)，signal driven IO(信号驱动IO)都是属于同步型IO，因为在第二个阶段: 从内核空间拷贝数据到程序空间的时候不能干别的事。
- 只有异步I/O模型(AIO)才是符合我们上面对于异步型IO操作的含义，在1.wait for data，2.copy data from kernel to user，这两个等待/接收数据的时间段内进程可以干其他的事情，只要等着被通知就可以了。

## Reactor模式和Proactor模式
其中NIO和AIO的概念比较容易混淆：
- NIO基于模式Reactor
- AIO基于Proactor模式


####  Reactor模式应用于同步I/O的场景，具体步骤：

**读取操作：**

1. 应用程序注册**读就绪事件**和相关联的事件处理器到时间分离器上（对应的selector）
2. 事件分离器等待事件的发生
3. 当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器
4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理

++写入操作类似于读取操作，只不过第一步注册的是写就绪事件。++

#### Proactor模式中读取操作和写入操作的过程：

**读取操作：**

1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注**读取完成事件**，==这是区别于Reactor的关键==。
2. 事件分离器等待读取操作完成事件
3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（**++异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色++**），并将读取的内容放入用户传递过来的缓存区中。==这也是区别于Reactor的一点==，Proactor中，应用程序需要传递缓存区。
4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

++写入操作类似于读取操作，只不过感兴趣的事件是写入完成事件。++


Reactor和Proactor模式的主要区别就是**真正的读取和写入操作是有谁来完成的**，
- Reactor中需要应用程序自己读取或者写入数据，
- Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备。

### 小结
名称|描述|含义
---|---|---
BIO|同步阻塞式IO|一个连接一个线程
NIO|同步非阻塞IO|一个io请求一个线程,总线轮询方式来获取io的消息
AIO|异步非阻塞IO|一个有效请求一个线程，把io的工作分出去，仅做通知后的回调程序即可

### BIO、NIO、AIO适用场景分析:

- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
- NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 
- AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

--------
> 在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

> 在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。

> 因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。

> 多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。

> 由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。

> 另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。