**public类的类名必须有与Java文件名一致**

**Java中只能有一个public类**

**声明常量的关键字：final（常量名称通常使用大写字母）**

**在主方法之外被调用需要加static**

**成员变量和局部变量可以重名，使用时，调用就近的变量（成员变量有默认值，局部变量没有默认值）**

**Java中只有true和false 没有 0和1 **

**加号“+”只有数字的时候是运算符，有字符串的时候是拼接符号（从左往右）【在Java中只有“+”倍重载了，其他的运算符都没有被重载也不能被重载】**

**& | 判断条件都会执行，最后得出结果**
**&& || 如果前面的判断条件已经得出结果，后面的条件就不执行**

**Math.random（）[0,1)的double型随机数**

**foreach循环**

```
for(类型 迭代变量 ： 数组或集合）
{代码块}**
```

**循环的跳出（break continue return）**
**break ： 跳出所在的switch或循环（跳出循环不论循环条件是否结束，循环都结束）**
**continue : 结束本次循环，进入下一次循环（不论continue后面是否有代码都结束本次）**
**return ： 离开语句所在方法**

**一维数组的声明和内存分配：**

```
数据类型[ ] 数组名； // 声明一维数组
数组名 = new 数据类型[ 长度]  //分配内存
```

**二维数组**

```
数据类型[ ] [ ] 数组名 = new 数据类型 [ 行个数] [ 列个数 ]
```

**访问修饰符：**

> **public：公有的 可跨类跨包访问 （本类 本包内类 包外类）**
> **protected：与继承有关 本类 子类可访问（相同包中的类可访问）**
> **private：私有的 本类访问**
> **默认模式：本类 本包可访问**
> **final 最终的 无法改变 （不能被继承）**
> 
> **static 语句块用于初始化static成员变量，是最先运行的语句块（比构造方法还要先运行）**

**匿名对象：没有名字的对象（创建对象只使用一次）**
**匿名类使用注意事项：**

> **1. 只能继承一个类和一个接口**
> **2. 不能定义构造函数**
> **3. 不能定义静态成员**
> **4. 不能是抽象的**

**对象比较：“= =”比较两个对象的内存地址；equals（）比较两个对象的内容**


----------
**栈内存和堆内存的区别：**

***栈内存：***

> **1. 栈是由编译器自动分配和释放的。**
> **2. 存放基本数据类型的变量、指令代码、常量和对象的引用地址**
> **3. 优点：**
> 				**存取速度快，数据可共享**
> **4. 缺点：**
> 				**存在栈中的数据大小与生命周期必须是确定的，缺少灵活性**

***堆内存：***

> **1. 堆是一个程序运行动态分配的内存区域**
> **2. 存放构建对象所需的内存**
> **3. 堆内存在使用完毕后，是由垃圾回收机制进行（隐式）回收**
> **4. 优点：**
> 				**动态分配内存大小**
> **5. 缺点：**
> 				**存取速度慢**


----------
**值传递：内容**
**引用传递：地址**

**this区分成员变量和局部变量（当这两个变量重名的时候）**
**this代表本类对象**

**方法的重载：（重载的定义与返回值无关）**

> **1. 必须在同一个类**
> **2. 必须方法名相同**
> **3. 必须参数列表不同（个数和类型中有一个或2个不同）**

**构造方法：（构造方法私有化后，该类的对象只能在本类中创建）**

> **1. 名称必须和所属的类的名称一致****
> **2. 没有返回值也不可以使用void关键字**
> **3. 可以被重载**
> **4. 不能被static和final修饰**
> **5. 不能被继承，如果子类要使用父类的构造方法，需要使用super关键字**

**代码块**

> **普通代码块：在方法名后或方法体内用一对{}括起来**
> **构造代码块：不在方法体内，仅位于类的范围内，执行多次，作用在于初始化成员变量**
> **静态代码块：当类被载入的时候，执行一次，作用在于初始化成员变量，静态代码块只能调用静态成员**
> **静态成员可以使用：类名（接口名）.静态成员**
> **static修饰的成员是共享的，又称为类成员**


----------


【**同步代码块：在线程部分涉及到！！！**】
**多线程：**

> **进程：进行的程序，操作系统资源分配的单位**
> **线程：是进程中的执行路径，进程的功能是靠进程中的多个线程执行的**

**实现多线程的两种方式：**

> **1. 将类声明为Thread子类，该类应该重写Thread类的run方法**
> **2. 声明实现Runable接口的类，该类实现run方法**

**多线程的同步：（同步的锁是this）**

> **1.同步代码块**
> 
> ``` synchronized（对象）{ //要同步的代码 } ```
> 
> **如果要完成同步，此处对象，必须是所有要同步的县城共享的一个对象**
> **2.同步方法：在普通方法上加一个synchronize修饰符**

**预防死锁：**

> **1.同步的代码尽力少**
> **2.同步的代码中尽量不要调用另一个相关类中的同步方法**

**线程间通信：**
**wait（）方法；notify（）方法**
**线程周期的控制：通过改变条件来结束，而不是通过stop**


----------


```
枚举 enum 枚举名{枚举值1，枚举值2，。。。}；
```

**定义：枚举名			变量名=枚举名.枚举值**
**枚举类和枚举关键字：**

```
枚举类：Enum（String name，int ordinal【从0开始】）
```

**values（）方法：返回枚举值组成的数组**
**enum（关键字）是Enum（类）的子类**

**类集对枚举的支持：**
**EnumMap			EnumSet**
**使用枚举注意事项：枚举的构造方法的访问权限只能是private或者默认，最后的枚举值要加“；”，枚举不能被继承**

**封装：将成员私有化，对外提供公共的访问方式**

**继承：class 子类名 extends 父类**
**继承的限制条件：**

> **1. Java中不允许多重继承，但是可以多层继承**
> **2. 父类私有成员不能被子类继承使用**
> **3. 子类在进行实例化时，首先调用父类的构造方法，然后调用子类的构造方法，super（），super.成员变量/方法**
> **4. final 修饰的不能被继承**

**覆写：子类定义了与父类相同的方法或属性，使用子类对象调用此方法时会调用子类的方法，子类重写父类的方法的访问修饰符不能严于父类，并且被覆写的方法不能为static**

**子类与父类可转型：向上转型，子类赋给父类；向下转型，父类赋给子类（强制转换）**

***重载与覆写的区别：***

> **重载：方法名相同，参数列表不同，在同一个类中；不受权限控制**
> **覆写：方法名相同，参数列表相同，返回值类型相同，在两个（直接或间接）父子类中；子类覆写父类方法的权限不能严于父类**

***this和super的区别：***

> **this：先从本类找成员，本类找不到在从父类找，this（[实参]）调用的是本类的构造方法，表示当前对象**
> **super：不查询本类的成员，直接在子类中调用父类的成员，super（[实参]）调用的是父类的构造方法，表示当前类的父类对象**

**final的使用：**

> **1. final修饰的类不能被继承**
> **2. final修饰的方法不能被子类覆写**
> **3. 使用final修饰的变量是常量（一旦赋值，不能更改），一般全部大写**

**抽象类：**

> **1. 抽象类和抽象方法必须用abstract关键字来修饰**
> **2. 抽象类不能直接实例化**
> **3. 抽象方法只需要声明，不需要实现**
> **4. 含有抽象方法的类必须是抽象类；抽象类的子类不需覆写所有的抽象方法，否则这个类还是抽象类**

**接口（interface）**

> **1. 接口中的成员变量：默认 public static final**
> **2. 接口中的成员方法：默认 public abstract**

**使用implements将子类实现接口**
**接口也可以extends接口**
***接口的作用：指定标准，设计模式，代理设置***

***抽象类和接口对比：***

**抽象类：**

> **语法：abstract class 类名{   }**
> **组成：常量、全局常量、变量、构造方法、普通方法、抽象方法**
> **权限：可以使用各种权限**
> **使用：子类通过extends关键字继承一个抽象类**
> **关系：一个抽象类可以实现多个接口**
> **设计模式：模板设计模式**
> **局限：单继承局限**

**接口：**

> **语法：interface 接口名{   }**
> **组成：全局常量 默认方法 抽象方法**
> **权限：都是public权限**
> **使用：子类通过implements关键字实现多个接口**
> **关系：一个接口不能继承抽象类，但可以继承多个接口**
> **设计模式：工厂设计模式，代理设计模式**
> **局限：没有单继承局限**

**Object类（所有类直接或间接的继承Object类）**

> **toString（）返回该对象的字符串表示，一般需要进行覆写**
> **equals（Object obj）表示其他某个对象是否与此对象相等，一般需要覆写**
> **hashcode（）返回该对象的哈希值**
> **使用Object接受任意引用数据类型对象（类 接口 数组都可以）**

**instanceof关键字：（返回boolean类型，一般配合向下转型使用）**

> **1. 可以用来判断一个类是否实现了一个接口**
> **2. 可以用来判断一个实例是否属于一个类**

**基本数据类型的包装类**

> **基本数据类型包装成相应的包装类，扩展功能：**
> **装箱：值类型--->引用数据类型**
> **拆箱：引用数据类型--->值类型**
> **基本数据类型和字符串的转换：查看API调用相应的方法**

**String类**
**声明方式：String 变量名**

```
两种实例化方式：String = “abc”；String s = new String（“abc”）
```

**这两种方式地址不同【具体哪里不同看下面】**

> **两种实例化方法的区别：变量名子啊栈内存，对象在堆内存**
> **第一种方法的字符串会进入字符串常量池，以后共享；第二种方法创建一个字符串对象和只想字符串的引用对象**
> **字符串常量是String类的匿名对象；字符串是常量一旦声明不能改变**
> **字符串拼接后生成一个新的字符串存放在字符串常量池中**


**对象的克隆：**
**对象克隆得到的副本与此对象的内容一致，但对象地址不同**
**如何克隆？**

> **1. 要克隆的对象所在的类不需实现接口Cloneable**
> **2. 在类中覆写其父类Object的clone（）方法**

**异常的基本概念**

```
try{ //可能出现异常的代码}
catch（异常类	对象名{//异常发生时处理的代码}
。。。
finally{//一定运行的代码}
```

**异常分为两大类：**

> **Error： JVM出错，用户无法在程序中处理这种错误**
> **Exception ：**
> **throw 关键字 ； throws 多个关键字**

**类集接口：**

> **collection：能操作一组对象，它位于类集层次结构的顶端**
> **List：扩展collection支持处理序列；有序，可重复**
> **Set：扩展collection支持处理序列；无序，不可重复**

**允许重复的自接口--List**

> **1. List接口的实现类ArrayList类：（动态）数组结构**
> **2.  List接口的实现类LinkedList类：链式结构**
> **3.  List接口的实现类Vector类：安全的，支持同步**

**数组操作类--Arrays**
**比较器：**

> **1.comparable接口（在类定义时要实现比较接口）**
> **2. comparator接口**

**不允许重复的接口--Set**

> **1. HashSet**
> **2. TreeSet：将存入元素自然排序**

**类集的输出：（迭代器）**

> **Iterator**
> **ListIterator（可在遍历时修改集合中的元素）**
> **Enumeration**
> **for（foreach输出）**

**偶对数保存接口--Map**

> **Map是由键值对组成（Map，Entry），其中的键是一个Set集合**
> **接口：1. Map接口  2. Map Entry  3. SortedMap**
> **实现类：1. HashMap  2. TreeMap  3. HashTree**

**给编译器看的注释--Annotation**

> **1. 含义：服务于编译器，属于一种配置信息**
> **2. 系统内建的Annotation：Override  Deprecated  SupressWarring**
> **3. 自定义Annotation：**
> 
> ``` [public] @interface 名称{ [数据类型  变量名称（）；] } ```
> 
> **自定义的Annotation如果变量没有默认值，那使用的时候必须给变量赋值，如果有默认值，使用的时候可以不赋值（直接使用默认值）**
> **4. Retention和RetentionPolicy：**
> **RetentionPolicy是一个枚举型，三个取值范围：SOURCE（源文件）,CLASS（类文件）,RUNTIME（运行时）**
> **5. 反射与Annotation：取得全部Annotation或者取得指定Annotation**
> **6. 深入Annotation：**
> 
> > **6.1 Target 限制注释出现的位置**
> > **6.2 Documented 可将自定义的注释设置为文档说明信息**
> > **6.3 Inhrited 用于标注一个父类的Annotation是否可以改变被子类继承**

**文件操作类--File（I/0相对内存来说）**

> **I：input 由外围设备读入内存**
> **O：output 由内存写出到外围设备**

**RandonAccessFile类：可以跳转带文件的任意位置处读写数据**

**字节流与字符流：**

> **字节流[非纯文本]：读 InputStream（抽象类） 子类：FileInputStream；写 OutputStream（抽象类） 子类 FileOutputStream**
> **字节流[纯文本]：读 Reader（抽象类）子类 FileReader；写Writer（抽象类）子类 FileWriter**

**字符流=字节流+编码**

**字节流与字符流转换：**

> **字节输入流-->字符输入流   	InputStreamReader**
> **字节输出流-->字符输出流   	OutputStreamWriter**

**管道流：管道输入流：PipeedInputStream；管道输出流：PipedOutputStream**

**内存操作流：**

> **字节：ByteArrayOutputStream;ByteArrayInputStream**
> **字符：CharArrayWriter；CharArrayReader**

**打印流：字节：PrintStream；字符PrintWriter**

**合并序列流：SequenceInputStream**

**System类对I/O的支持**
**字符编码：乱码的原因，编码和解码不一致**

**对象序列化：**

> **1.对象所在的类必须实现Serualizable接口**
> **2.ObjectOutputStream   	ObjectInputStream**

