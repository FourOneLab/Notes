# 7.1. ActiveMQ

ActiveMQ 是由 Apache 出品，ActiveMQ 是一个完全支持JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。它非常快速，支持 **多种语言的客户端** 和 **协议**，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。

![image](https://access.redhat.com/documentation/en-US/Fuse_ESB/4.4.1/html-single/ActiveMQ_Tuning_Guide/images/general_05.gif)

## (a) 主要特性

1. **服从JMS规范**：JMS 规范提供了良好的标准和保证，包括：**同步** 或 **异步** 的消息分发，一次和仅一次的消息分发，**消息接收** 和 **订阅** 等等。遵从 JMS 规范的好处在于，不论使用什么 JMS 实现提供者，这些基础特性都是可用的；
2. **连接灵活性**：ActiveMQ 提供了广泛的 连接协议，支持的协议有：HTTP/S，IP 多播，SSL，TCP，UDP 等等。对众多协议的支持让 ActiveMQ 拥有了很好的灵活性；
3. **支持的协议种类多**：OpenWire、STOMP、REST、XMPP、AMQP；
4. **持久化插件和安全插件**：ActiveMQ 提供了 多种持久化 选择。而且，ActiveMQ 的安全性也可以完全依据用户需求进行 自定义鉴权 和 授权；
5. **支持的客户端语言种类多**：除了 Java 之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；
6. **代理集群**：多个 ActiveMQ 代理 可以组成一个 集群 来提供服务；
7. **异常简单的管理**：ActiveMQ 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 监控 ActiveMQ 不同层面的数据，包括使用在 JConsole 或者在 ActiveMQ 的 Web Console 中使用 JMX。通过处理 JMX 的告警消息，通过使用 命令行脚本，甚至可以通过监控各种类型的 日志。
## (b) 部署环境

ActiveMQ 可以运行在 Java 语言所支持的平台之上。使用 ActiveMQ 需要：

- Java JDK
- ActiveMQ 安装包
## (c) 优点

1. **跨平台** (JAVA 编写与平台无关，ActiveMQ 几乎可以运行在任何的 JVM 上)；
2. 可以用 **JDBC**：可以将 数据持久化 到数据库。虽然使用 JDBC 会降低 ActiveMQ 的性能，但是数据库一直都是开发人员最熟悉的存储介质；
3. 支持 **JMS** 规范：支持 JMS 规范提供的 统一接口;
4. 支持 **自动重连** 和 **错误重试机制**；
5. **有安全机制**：支持基于 shiro，jaas 等多种 安全配置机制，可以对 Queue/Topic 进行 认证和授权；
6. **监控完善**：拥有完善的 监控，包括 Web Console，JMX，Shell 命令行，Jolokia 的 RESTful API；
7. **界面友善**：提供的 Web Console 可以满足大部分情况，还有很多 第三方的组件 可以使用，比如 hawtio；
## (d) 缺点

1. 社区活跃度不及 RabbitMQ 高；
2. 根据其他用户反馈，会出莫名其妙的问题，会 丢失消息；
3. 目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；
4. 不适合用于 上千个队列 的应用场景；

# 7.2. RabbitMQ

RabbitMQ 于 2007 年发布，是一个在 AMQP (**高级消息队列协议**)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
![image](http://p1.pstatp.com/large/pgc-image/15317228441737abea255d3)

## (a) 主要特性

1. **可靠性**：提供了多种技术可以让你在 性能 和 可靠性 之间进行 权衡。这些技术包括 持久性机制、投递确认、发布者证实 和 高可用性机制；
2. **灵活的路由**：消息在到达队列前是通过 交换机 进行 路由 的。RabbitMQ 为典型的路由逻辑提供了 多种内置交换机 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 RabbitMQ 的 插件 来使用；
3. **消息集群**：在相同局域网中的多个 RabbitMQ 服务器可以 聚合 在一起，作为一个独立的逻辑代理来使用；
4. **队列高可用**：队列可以在集群中的机器上 进行镜像，以确保在硬件问题下还保证 消息安全；
5. **支持多种协议**：支持 多种消息队列协议；
6. **支持多种语言**：用 Erlang 语言编写，支持只要是你能想到的 所有编程语言；
7. **管理界面**： RabbitMQ 有一个易用的 用户界面，使得用户可以 监控 和 管理 消息 Broker 的许多方面；
8. **跟踪机制**：如果 消息异常，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；
9. **插件机制**：提供了许多 插件，来从多方面进行扩展，也可以编写自己的插件。
## (b) 部署环境

RabbitMQ 可以运行在 Erlang 语言所支持的平台之上，包括 Solaris，BSD，Linux，MacOSX，TRU64，Windows 等。使用 RabbitMQ 需要：

- ErLang 语言包
- RabbitMQ 安装包
## (c) 优点

1. 由于 Erlang 语言的特性，消息队列性能较好，支持 高并发；
2. 健壮、稳定、易用、**跨平台**、支持 多种语言、文档齐全；
3. 有消息 **确认机制** 和 **持久化机制**，可靠性高；
4. 高度可定制的 路由；
5. **管理界面** 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。
## (d) 缺点

1. 尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做 二次开发和维护；
2. 实现了 **代理架构**，意味着消息在发送到客户端之前可以在 中央节点 上排队。此特性使得 RabbitMQ 易于使用和部署，但是使得其 运行速度较慢，因为中央节点 增加了延迟，消息封装后 也比较大；
3. 需要学习 **比较复杂** 的 接口和协议，学习和维护成本较高。

# 7.3. RocketMQ

RocketMQ 出自 阿里 的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，**消息可靠性上** 比 Kafka 更好。RocketMQ 在阿里内部被广泛应用在 订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发 等场景。

![image](http://p99.pstatp.com/large/pgc-image/1531722844137ad46da8e73)
## (a) 主要特性
1. 基于 **队列模型**：具有 高性能、高可靠、高实时、分布式 等特点；
2. Producer、Consumer、队列 都支持 分布式；
3. Producer 向一些队列轮流发送消息，队列集合 称为 Topic。Consumer 如果做 广播消费，则一个 Consumer 实例消费这个 Topic 对应的 所有队列；如果做 集群消费，则 多个 Consumer 实例 平均消费 这个 Topic 对应的队列集合；
4. 能够保证 **严格的消息顺序**；
5. 提供丰富的 **消息拉取模式**；
6. 高效的订阅者 **水平扩展能力**；
7. 实时 的 **消息订阅机制**；
8. 亿级 **消息堆积** 能力；
9 较少的外部依赖。
## (b) 部署环境

RocketMQ 可以运行在 Java 语言所支持的平台之上。使用 RocketMQ 需要：

- Java JDK
- 安装 git、Maven
- RocketMQ 安装包
## (c) 优点

1. **单机** 支持 1 万以上 持久化队列；
2. RocketMQ 的所有消息都是 持久化的，先写入系统 PAGECACHE，然后 刷盘，可以保证 内存 与 磁盘 都有一份数据，而 访问 时，直接 从内存读取。
3. 模型简单，接口易用（JMS 的接口很多场合并不太实用）；
4. **性能非常好**，可以允许 大量堆积消息 在 Broker 中；
5. 支持 多种消费模式，包括 集群消费、广播消费等；
6. 各个环节 **分布式扩展设计**，支持 主从 和 高可用；
7. 开发度较活跃，版本更新很快。
## (d) 缺点

1. 支持的 **客户端语言** 不多，目前是 Java 及 C++，其中 C++ 还不成熟；
2. RocketMQ 社区关注度及成熟度也不及前两者；
3. 没有 Web 管理界面，提供了一个 CLI (命令行界面) 管理工具带来 查询、管理 和 诊断各种问题；
4. 没有在 MQ 核心里实现 JMS 等接口；

# 7.4. Kafka

Apache Kafka 是一个 **分布式消息发布订阅** 系统。它最初由 LinkedIn 公司基于独特的设计实现为一个 **分布式的日志提交系统** (a distributed commit log)，之后成为 Apache 项目的一部分。Kafka 性能高效、可扩展良好 并且 可持久化。它的 分区特性，可复制 和 可容错 都是其不错的特性。![image](http://p3.pstatp.com/large/pgc-image/153172284405265f2415cd9)

## (a) 主要特性

1. **快速持久化**：可以在 O(1) 的系统开销下进行 消息持久化；
2. **高吞吐**：在一台普通的服务器上既可以达到 10W/s 的 吞吐速率；
3. **完全的分布式系统**：Broker、Producer 和 Consumer 都原生自动支持 分布式，自动实现 负载均衡；
4. 支持 **同步** 和 **异步** 复制两种 高可用机制；
5. 支持 **数据批量发送** 和 拉取；
6. **零拷贝技术**(zero-copy)：减少 IO 操作步骤，提高 系统吞吐量；
7. **数据迁移**、**扩容** 对用户透明；
8. **无需停机** 即可扩展机器；
9. **其他特性**：丰富的 **消息拉取模型**、高效 **订阅者水平扩展**、实时的 消息订阅、亿级的 消息堆积能力、定期删除机制；
## (b) 部署环境

使用 Kafka 需要：

- Java JDK
- Kafka 安装包
## (c) 优点

1. **客户端语言丰富**：支持 Java、.Net、PHP、Ruby、Python、Go 等多种语言；
2. **高性能**：单机写入 TPS 约在 100 万条/秒，消息大小 10 个字节；
3. 提供 **完全分布式架构**，并有 replica 机制，拥有较高的 可用性 和 可靠性，理论上支持 消息无限堆积；
4. 支持批量操作；
5. **消费者** 采用 Pull 方式获取消息。消息有序，通过控制 能够保证所有消息被消费且仅被消费 一次；
6. 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；
7. 在 **日志领域** 比较成熟，被多家公司和多个开源项目使用。
## (d) 缺点

1. Kafka 单机超过 64 个 队列/分区 时，Load 时会发生明显的飙高现象。队列 越多，**负载** 越高，发送消息 响应时间变长；
2. 使用 **短轮询方式**，**实时性** 取决于 轮询间隔时间；
3. 消费失败 **不支持重试**；
4. 支持 **消息顺序**，但是 一台代理宕机 后，就会产生 消息乱序；
5. 社区更新较慢。

# 7.5. 几种消息队列对比

![image](http://p99.pstatp.com/large/pgc-image/1531723301229012b04e072)

Kafka 在于 **分布式架构**，RabbitMQ 基于 **AMQP** 协议 来实现，RocketMQ 的思路来源于 Kafka，改成了 **主从结构**，在 **事务性** 和 **可靠性** 方面做了优化。广泛来说，电商、金融 等对 **事务一致性** 要求很高的，可以考虑 RabbitMQ 和 RocketMQ，对 **性能要求高** 的可考虑 Kafka。