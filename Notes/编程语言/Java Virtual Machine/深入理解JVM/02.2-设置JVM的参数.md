# 堆

参数 | 含义
---|---
-Xms | 堆内存最小值
-Xmx | 堆内存最大值
-XX:+HeapDumpOnOutOfMemoryError| 让虚拟机在出现内存溢出时，Dump当前内存堆转储快照

### 常见异常信息和解决方案：

- Java堆内存溢出是，异常堆栈信息“java.lang.OutOfMemoryError：Java heap space”


- 先通过内存映像分析工具（Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点确认内存中的对象是否是必须的，也就是要先分清楚是出现了内存的泄漏（Memory Leak）还是内存的溢出（Memory Overflow）

##### 内存泄漏
如果存在泄漏，通过工具查看泄漏对象到GC Roots是的引用链。==找到泄漏对象是通过怎么样的路径与GC Roots相关联并导致辣鸡收集器无法自动回收它们的==。掌握泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位到泄漏代码的位置。


##### 内存溢出
如果不存在泄漏，也就是说内存中的对象确实都还必须存活着，那就应该检查jvm堆参数（-Xms和-Xmx）与物理内存的大小，是否能够调大。或者==从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况==，尝试减少程序运行期的内存消耗。

# 虚拟机栈与本地方法栈
在Hotspot虚拟机汇总，不区分虚拟机栈（-Xss）和本地方法栈（-Xoss），栈容量由前者决定，后者无效。


参数| 含义
---|---
-Xss| 虚拟机栈
-Xoss | 本地方法栈



虚拟机栈和本地方法栈中存在两种异常：
1. StackOverflowError：线程请求的栈深度大于虚拟机运行的最大深度
2. OutOfMemoryError：虚拟机在扩展栈时无法申请到足够的内存空间

> 在单线程情况下，无论是栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。

> 多线程的情况下，不断的建立线程或导致内存溢出异常，但是这样产生的内存溢出与栈空间是否足够大并不存在任何联系，或者准确的说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。


==**如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多线程**==

++在Windows平台的虚拟机中，Java线程是映射到操作系统的内核线程上的。++


# 方法区和运行时常量池
在JDK1.6及之前的版本中，常量池分配在永久代中，可以通过-XX：PermSize和-XX：MaxPermSize限制方法区的大小

参数| 含义
---|---
-XX：PermSize | 方法区最小值（永久代最小值）
-XX：MaxPermSize| 方法区最大值（永久代最大值）

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

方法区溢出是一种常见的内存溢出异常，一个类被垃圾回收器回收掉的判断条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。


# 本机内存直接溢出
参数| 含义
---|---
-XX：MaxDirectMemorySize|直接内存

如果不指定，则默认与Java堆(-Xmx指定)最大值一样。

有DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM后Dump文件很小，而程序中又直接或间接使用了NIO，可以考虑是直接内存溢出。