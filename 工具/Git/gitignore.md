# 语法

1. 空行不匹配任何文件，因此它可以作为可读性的分隔符。

2. 以＃开头的行作为注释。对于以哈希开头的模式，在第一个哈希前面加一个反斜杠（“\”）。

3. 除非使用反斜杠（“\”）引用尾随空格，否则将忽略尾随空格。

4. 可选前缀“！”否定了这种模式;之前模式排除的任何匹配文件将再次包含在内。如果排除该文件的父目录，则无法重新包含文件。出于性能原因，Git不会列出排除的目录，因此无论在何处定义，所包含文件的任何模式都不起作用。在第一个“！”前放一个反斜杠（“\”）对于以文字“！”开头的模式，例如“\！important！.txt”。

5. 如果模式以斜杠结尾，则为了以下描述的目的将其删除，但它只会找到与目录的匹配项。换句话说，foo /将匹配目录foo和它下面的路径，但是不匹配常规文件或符号链接foo（这与pathpec在Git中的工作方式一致）。

6. 如果模式不包含斜杠/，Git将其视为shell glob模式，并检查相对于.gitignore文件位置的路径名匹配（相对于工作树的顶层，如果不是来自.gitignore）文件）。

7. 否则，Git将模式视为shell glob：“*”匹配除“/”，“？”之外的任何内容。匹配除“/”之外的任何一个字符，“[]”匹配所选范围中的一个字符。有关更详细的说明，请参阅fnmatch（3）和FNM_PATHNAME标志。

8. 前导斜杠与路径名的开头匹配。例如，“/ *。c”匹配“cat-file.c”但不匹配“mozilla-sha1 / sha1.c”。

与完整路径名匹配的两个连续星号（“**”）可能具有特殊含义：

- 前面的斜杠“**”表示匹配所有目录。例如，“** / foo”在任何地方匹配文件或目录“foo”，与模式“foo”相同。 “** / foo / bar”将文件或目录“bar”与直接位于“foo”目录下的任何位置匹配。

尾随“/ **”匹配内部的所有内容。例如，“abc / **”匹配目录“abc”内的所有文件，相对于.gitignore文件的位置，具有无限深度。

斜杠后跟两个连续的星号，然后斜杠匹配零个或多个目录。例如，“a / ** / b”匹配“a / b”，“a / x / b”，“a / x / y / b”等。

其他连续的星号被认为是常规星号，并且将根据先前的规则匹配。
