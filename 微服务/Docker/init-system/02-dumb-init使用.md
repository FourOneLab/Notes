dumb-init是一个简单的进程管理器和init系统，设计用于在最小容器环境（如Docker）中作为`PID 1`运行。它被部署为一个用C编写的小型静态链接二进制文件。

轻量级容器已经普及了运行单个进程或服务的想法，而没有像`systemd`或`sysvinit`这样的普通初始化系统。**但是，省略init系统通常会导致对进程和信号的错误处理，并且可能导致诸如无法正常停止容器或泄漏应该被销毁的容器之类的问题**。

`dumb-init`使你可以以简单的命令前缀的方式使用它，来充当`PID 1`并立即将你的命令作为子进程生成，并在收到信号时正确处理和转发信号。

# 为何需要一个init系统
通常，当你启动Docker容器时，你正在执行的进程将变为`PID 1`，从而赋予它作为容器的init系统所带来的怪癖和责任。这提出了两个常见问题：
1. 在大多数情况下，信号将无法正确处理
> Linux内核对作为`PID 1`运行的进程应进行特殊的信号处理。当进程在普通Linux系统上发送信号时，内核将首先检查进程为该信号注册的任何自定义信号处理器，否则将回退到默认行为（例如，在`SIGTERM`上终止进程）。但是，如果接收信号的进程是`PID 1`，则由内核会进行特殊处理;如果它没有为信号注册处理器，内核将不会回退到默认行为，并且不做任何反应。换句话说，如果你的进程没有明确处理这些信号的信号处理器，发送SIGTERM信号给它将完全没有效果。一个常见的例子是使用docker运行`my-containe`r脚本的CI作业：将`SIGTERM`发送到`docker run`进程通常会终止`docker run`命令，但容器却还在后台运行着而没有被终止。

2. 孤儿僵尸进程无法被适当的方式捕获
> 进程在退出时变为僵尸，并且在其父进程调用`wait（）`系统调用的某些变体之前保持僵尸状态。它作为“已停止”的进程保留在进程表中。通常，父进程会立即调用`wait（）`并避免常驻僵尸进程。如果父进程在其子进程之前退出，则该子进程就变成“孤立的”，并且在`PID 1`下重新挂载父进程。因此，init系统负责调动`wait（）`处理孤儿僵尸进程。当然，大多数进程都不会在碰巧附加到它们的随机进程上调用`wait（）`，因此容器通常以几个根植于`PID 1`的僵尸进程结束。

# dumb-init能做什么
`dumb-init`作为`PID 1`运行，就像一个简单的init系统。它启动一个进程，然后将所有收到的信号代理到以该子进程为根的会话。

由于你的进程不再是`PID 1`，当它从`dumb-init`接收信号时，将应用默认的信号处理程序，并且你的进程将按照预期运行。如果你的进程死了，`dumb-init`也会死掉，注意清理可能仍然存在的任何其他进程。

## 会话行为
在默认模式下，`dumb-init`建立以子进程为根的会话，并将信号发送到整个进程组。如果你有一个表现不佳的子进程（比如一个shell脚本），这个子进程在死亡前通常不会给它的子进程发出信号，这很有用。

这实际上可以在常规进程监视器（如daemontools或supervisord）中的Docker容器之外用于监视shell脚本。通常，shell接收到的`SIGTERM`之类的信号不会转发给它的子进程;相反，只有shell进程死掉才会发送信号。如果使用`dumb-init`，你可以在`shebang`中使用`dumb-init`编写shell脚本：

```bash
#!/usr/bin/dumb-init /bin/sh
my-web-server &  # launch a process in the background
my-other-server  # launch another process in the foreground
```

通常，发送到shell的`SIGTERM`会杀死shell，但这些进程仍然会处于运行状态（不论是后台还是前台进程）。使用`dumb-init`，你的子进程将收到与shell所执行的相同的信号。

如果你希望仅将信号发送到直接子进程，则可以使用`--single-child`参数运行，或者在运行`dumb-init`时设置环境变量`DUMB_INIT_SETSID = 0`。在这种模式下，`dumb-init`完全透明;你甚至可以把多个串起来（比如`dumb-init dumb-init echo'oh，hi'`）。


## 信号重写
`dumb-init`允许在代理它们之前重写输入信号。这在始终发送标准信号（例如SIGTERM）的Docker 容器管理程序（如Mesos或Kubernetes）中非常有用。某些应用程序需要不同的停止信号才能进行优雅的清理退出。

> 例如，要将信号SIGTERM（编号15）重写为SIGQUIT（编号3），只需在命令行中添加`--rewrite 15：3`即可。要完全丢弃信号，可以将其重写为特殊数字0。

### 信号重写特例
在`setsid`模式下运行时，在大多数情况下转发`SIGTSTP/SIGTTIN/SIGTTOU`是不够的，因为，如果进程没有为这些信号添加自定义信号处理器，内核将不会应用默认信号处理行为（这将暂停进程），因为它是孤儿进程组的成员。因此，将这三个信号的默认重写设置为`SIGSTOP`。如果需要，可以通过将信号重写回原始值来选择不使用此行为。

有一点需要注意：对于作业控制信号（SIGTSTP，SIGTTIN，SIGTTOU），`dumb-init`在收到信号后总是会自动挂起，即使你把它重写为其他东西也是如此。

# 在Docker 容器内安装

