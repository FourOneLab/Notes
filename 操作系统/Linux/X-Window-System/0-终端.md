# 定义
终端就是处理计算机主机输入输出的一套设备，它用来显示主机运算的输出，并且接受主机要求的输入，典型的终端包括显示器键盘套件，打印机打字机套件等。

> 终端与主机的连接方式：通过串口连接，或者通过TCP/IP网络连接。

# 终端的历史
## 操作台
一开始计算机只有一个操作台也就是终端。

## 多终端
后来出现了**多用户多任务分时系统**，为了让不同的程序分别独立地接受输入和输出，需要有多个操作台，这就有了多终端。

从那时起，每个终端和一个用户绑定，**为了实现这种绑定，出现了登录**。

> 登录动作会唤起一个终端，为了支持多用户，终端从硬件中分离。终端成为了软件概念，在一个硬件终端上成功登录后，获得一个软件终端。

**分久必合**

## PC时代
个人计算机时代，计算机和终端又成了一一对应的关系，甚至淡化了多用户和多终端的概念，甚至出现了一体机和触屏。

**合久必分**

## 云计算时代
各种物联网设备，都成了云端的一个终端而已，只是用来完成与云端的输入和输出交互。


## 总结
不管什么时代，终端始终扮演着人机接口的角色，Terminal，即机器的边缘。

只要能提供给计算机输入和输出功能，那它就是终端，与其所在的位置无关。

- SSH是一个TCP/IP协议族的协议，而其上跑的却是一个远程登录后的终端流，这显然只是用TCP/IP构建了一条隧道，然后终端流通行于该隧道。
- 更简单的Telnet也是通过一个TCP/IP隧道来封装承载远程登录的终端流。

> 除去TCP/IP，如果我们执意使用卡车来运载我们的输入和输出，也完全是合适的，TCP/IP也好，卡车也好，它们只是**通信手段**，它们并非终端本身。

# 终端的存在形式
1. 本地终端：用VGA连接主机和显示器，用PS/2或者USB连接主机和键盘，这样的一个显示器/键盘组合就是一个本地终端。
2. 用串口连接的远程终端：通过串口线把主机接到另外一个有显示器和键盘的主机，通过运行一个终端模拟程序，比如“Windows超级终端”来将这台主机的显示器和键盘借给串口对端的主机。
3. 用TCP/IP承载的远程终端：类似Telnet，SSH这般。

> 前两类都是在本地就直接关联了物理设备的，比如VGA口，PS/2口，串口之类，这种终端叫做**物理终端**，

> 第三类在本地则没有关联任何物理设备，**注意，不要把物理网卡当成终端关联的物理设备，它只是隧道关联的物理设备**，这里的物理网卡完全可以换成卡车，它们与终端并不直接相关，所以这类不直接关联物理设备的终端叫做**伪终端**。

# Linux系统中的终端
**tty（Teletypes）**

在Linux系统中，`/dev/ttyX`代表的就是上述的**物理终端**，其中`/dev/tty`~`/dev/tty63`代表的是本地终端，也就是接到本机的键盘显示器可以操作的终端。
> 举个例子，往/dev/tty3里面写个东西，它就会显示在显示器对应的终端。

虽然显示器和键盘只是一个单独的设备，Linux在初始化的时候会生成63个本地终端，通过键盘上的Fn-Alt-FX(X为1,2,3…)可以在这些终端之间切换，每切换到一个终端，该终端就是当前的**焦点终端**。
> 举个例子，按下了Fn-Alt-F4组合键，那么此时第4个终端就是焦点终端，即/dev/tty4就是焦点终端设备。

谁是焦点终端，就会被内核记录为全局变量，这时键盘就作为焦点终端的输入设备，把输入的字符交给焦点终端。

- 对于串口，不存在焦点终端，谁连接了串口，那就是谁。
- 对于伪终端，一般情况下client运行在GUI环境，Linux下由X11系统处理。

> 系统中有一个变量用于表示焦点终端，`/dev/console`,无论从哪里往`/dev/console`中写东西，都会出现在系统当前的焦点终端上。

> 系统中有一个变量用于表示自己，`/dev/tty`，无论在哪个终端下工作，当往`/dev/tty`里面写东西的时候，它总是会马上出现在你眼前。

|变量|含义|
|---|---|
|/dev/tty1~63|物理终端|
|/dev/tty|自己|
|/dev/console|焦点终端|
|/dev/ttyS1~n|串口连接的终端（以ttyS开头)|
|ptmx|sshd或telnetd中的虚拟终端|
|pts/X|与ptmx配对的子进程中的虚拟终端|


## 伪终端

系统中ssh没有对应的物理设置，通过模拟的方式实现。系统是分层的，执行流只负责调用接口，不管具体实现。模拟一个虚拟的终端，实现它的write和read等调用即可。
> 举个例子，对于VGA连接的显示器，write其实就是刷新显存，对于伪终端而言，write是想要将数据导入到一个用户态的程序中。

为此，Linux设计出了一对虚拟终端设备，即`/dev/ptmx`和`/dev/pts/X`。

> 当ssh客户端连接后，sshd会fork一个进程，然后在子进程中打开一个叫做`/dev/pts/1～n`的设设备，然后和sshd进程的`/dev/ptmx`配对，这样在ptmx与pts之间就构成了一条管道，数据可以顺利被导入到sshd，然后通过TCP/IP封装发往ssh client所在的机器。

具体实现方式如下图所示：

![image](https://img-blog.csdn.net/20171213082308503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG9nMjUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

------
# getty&login
在多终端时代，每个终端必须绑定一个用户，只有登录成功的用户方可获得一个终端。

1. getty给了让你登录并且继续输入的机会，init进程不断调用getty，然后getty发起login让你登录。
2. 当输入正确的用户名和密码之后，ttyXYZ就是你的
  - 如果是通过ssh登录，那么你会获得一个`/dev/pts/X`
  - 如果通过显示器和键盘登录，那么你会获得一个`/dev/ttyX`（x 取决与当前的焦点终端）
