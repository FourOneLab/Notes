# 版本的特性：
- Go1.5 自举，即通过Go语言编写程序来实现Go语言自身
- Go1.7 极速垃圾回收器
- Go1.10 对自带工具全面升级
- 做程序依赖管理的go mod命令

# 环境变量
- GOROOT：Go语言安装根目录的路径，即Go语言的安装路径
- GOPATH：若干工作区目录的路径，用户自定义的工作空间【背后的概念最多，最重要】
- GOBIN：Go程序生成的可执行文件的路径

# 设置GOPATH有什么意义？
GOPATH是Go语言的工作目录，它的值是一个或多个目录的路径，每个目录都代表Go语言的一个工作区（Workspace）。

利用工作区去存放：
1. Go语言的源码文件（source file）
2. 安装后的归档文件（archive file，以`.a`为扩展名的文件）
3. 可执行文件

> 事实上，由于Go语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着GOPATH和工作区进行的。

GOPATH背后有三个知识点：
1. **Go语言源码的组织方式是怎样的**
2. **源码安装后的结果（只有在安装后，Go语言源码才能被其他代码使用）**
3. **理解构建和安装Go程序的过程（开发问题以及查找问题的时候非常有用）**

## Go语言源码的组织方式
Go语言的源码以代码包为基本组织单位，在文件系统中，这些代码包是与目录一一对应的（目录有子目录，所以代码包有子包）。

- 一个代码包中包含多个以`.go`为扩展名的源码文件，**这些源码文件都需要被声明属于同一个代码包**。
- 代码包的名称一般会与源码文件所在的目录同名。（如果不同名，在构建安装过程中以代码包的名字为准）。
- 每个代码包都会有**导入路径**（即，其他代码在使用该包中的程序实体时，需要引入的路径）。

在实际使用程序实体之前，必须先导入其所在的代码包。具体方式就是import该代码包的导入路径：
```go
import "github.com/labstack/echo"
```
**在工作区中，一个代码包的导入路径实际就是从src子目录到该包的实际存储位置的相对路径**。

> Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录和代码包为主线的。

一般情况下，Go语言的源码文件都需要被存放在环境变量GOPATH包含的某个工作区中的src目录下的某个包中。

## 源码安装后的结果
Go语言源码在安装后会产生什么样的结果？源码文件以及安装后的结果文件（归档文件以`.a`为扩展名）会存放在哪里？

> 源码文件会存放在工作区的`src子目录`中，安装后的归档文件会存放在工作区的`pkg子目录`中，如果安装后产生了可执行文件，就可能会放在该工作区的`bin子目录`中。

源码文件是以代码包的形式组织起来的，一个代码包对应一个目录，安装某个代码包而产生的归档文件是与这个代码包同名的。`放置它的相对目录就是该代码包的导入路径的直接父级`。

### 举个例子
一个已经存在的代码包的导入路径如下：
```go
github.com/labstack/echo
// 该代码包的源码文件存在与GitHub网站的labstack组的代码仓库echo中
```
执行安装命令后：
```go
go install github.com/labstack/echo
```
生成的归档文件的相对目录就是`github.com/labstack`，文件名为`echo.a`。

**上述例子中。代码包的归档文件就会被放置在当前工作区的子目录：`pkg/linux_amd64/github.com/labstack`中**。

注意：在归档文件的相对目录与pkg目录之间还有一级目录，叫做**平台相关目录**。

平台相关目录的名称是由build，即构建过程的：
1. 目标操作系统
2. 下环线
3. 目标计算机架构的代号

三部分组成。

总之，某个工作区的src子目录下的源码文件在安装之后，一般会被放置在当前工作区的pkg子目录下对应的目录中，或者被直接放置在该工作区的bin子目录中。如下图所示：

![image](https://static001.geekbang.org/resource/image/2f/3c/2fdfb5620e072d864907870e61ae5f3c.png)

## 构建和安装Go程序的过程
- 构建使用go build
- 安装使用go install

构建和安装代码包的过程中都会执行编译、打包等操作，并且操作生成的任何文件都会先被保存在某个临时的目录中。

### 构建
1. 如果构建的是**库源码文件**，那么操作后产生的结果文件只会存在于临时目录中。**这里的构建主要意义在于检查和验证**。
2. 如果构建的是**命令源码文件**，那么操作的结果文件会被搬运到源码文件所在的目录中。

### 安装
安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。

1. 如果安装的是**库源文件**，那么结果文件会被搬运到它所在工作区的pkg目录下的某个子目录中。
2. 如果安装的是**命令源文件**，那么结果文件会被搬运到它所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。


# 总结
Go语言提供的很多工具都是在GOPATH和工作区的基础上运行的，比如，go build、go install、go get等。


-----
补充
# go build
在运行go build 命令的时候，默认不会编译目标代码包所依赖的那些代码包。**如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那么它还是会被编译的**。

## 参数解释
- `-a`，进行强制编译，这时代码包和它依赖的代码包（即使依赖的是标准库中的代码包）都会被编译。
- `-i`，不但要编译依赖的代码包，同时要安装它们的归档文件，在上面的基础上增加这个参数。
- `-x`，可以看到go build命令具体执行了哪些操作。
- `-n`，只查看go build命令的具体执行的操作但是并不执行这些操作。
- `-v`，可以查看到go build命令编译的代码包的名称，通常与`-a`参数搭配使用。

# go get
go get命令会自动从一些主流的公用代码库（如GitHub）下载目标代码包，并把它们安装到GOPATH包含**的第一个工作区**的相应目录中。

如果存在GOBIN环境变量，那么**仅包含命令源码文件**的代码会被安装到GOBIN指向的那个目录中。


## 参数解释
- `-u`，下载并安装代码包，不论工作区中是否存在它们。
- `-d`，只下载代码包，不安装。
- `-fix`，在下载代码包后先运行一个用于根据当前Go语言版本修正代码的工具，然后在安装代码包。
- `-t`，同时下载测试所需的代码包。
- `-insecure`，允许通过非安全的网络协议（如HTTP）下载和安装代码包。

> Go语言官方提供的go get命令是非常基础的，其中并没有提供**依赖管理功能**。目前GitHub上有很多提供这类功能的第三方工具，比如glide、gb以及官方出品的dep、vgo等，它们在内部大多会直接受用go get。

## 修改源码存储路径
当修改存储源码的代码仓库或者代码包的相对路径时，为了让代码包的远程导入路径不收此类变更的影响，可以使用自定义的代码包导入路径。

对代码包的远程导入路径进行自定义：在该代码包中的**库源码文件**的包声明语句的右侧加入导入注释，如下：
```go
package somaphore // import "golang.org/x/sync/semaphore"
```
这个代码包原来的完整导入路径是`github/golang/x/sync/semaphore`，这与实际存储它的网络地址一样,该代码包的源码实际存放在GitHub网站的golang组的sync代码仓库的semaphore目录下。加入导入注释后，用以下命令即可下载并安装该代码包了：
```go
go get golang.org/x/sync/semaphore
```
> 在Go语言官网golang.org下的路径`/x/sync/semaphore`并不存放semaphore包的真实地址。称之为代码包的自定义导入路径。

不过，这还是需要在golang.org这个域名背后的服务端程序上，添加一些支持才能使这条命令成功。具体参考这里：https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md

